1. Data Modeling & Database
a. Village Partners Table
Create a new table (e.g., village_partners) in your Drizzle schema for storing each partner. Columns could include:

id: Primary key
userId: Foreign key referencing the users table (the user that owns the partner record)
name: The user-facing name (e.g. “Oma & Opa”)
circleLevel: Integer 1 through 5 to indicate which concentric circle the partner belongs to
category: Possibly an enum or a text field if you have multiple categories (e.g., “formeel”, “informeel”, “inspiratie”)
contactFrequency: Possibly an enum/text for S, M, L, XL
otherMetadata: JSON or structured columns for anything else you might track (like “Film,” “Muziek,” “Therapie,” etc.)
ts
Copy
// db/schema.ts (Drizzle)
import { pgTable, serial, text, integer, pgEnum } from "drizzle-orm/pg-core";
import { users } from "./users";

export const categoriesEnum = pgEnum("categoryEnum", [
  "informeel",
  "formeel",
  "inspiratie",
  // ... etc
]);

export const villagePartners = pgTable("village_partners", {
  id: serial("id").primaryKey(),
  userId: integer("user_id")
    .references(() => users.id)
    .notNull(),
  name: text("name").notNull(),
  circleLevel: integer("circle_level").notNull(), // 1 through 5
  category: categoriesEnum("category"),
  contactFrequency: text("contact_frequency"), // "S", "M", "L", "XL"
  // If needed:
  // otherMetadata: json("other_metadata").default("{}")
});
Then run your migration via Drizzle Kit.

2. Backend Endpoints
You’ll need CRUD endpoints for village_partners so the front end can:

GET /api/village-partners: fetch a user’s full village
POST /api/village-partners: create a new partner
PUT /api/village-partners/:id: edit a partner’s circle level, category, name, etc.
DELETE /api/village-partners/:id: remove a partner
Example Implementation
ts
Copy
// routes/villagePartners.ts
import express from "express";
import { db } from "../db/index"; // Drizzle instance
import { villagePartners } from "../db/schema";
import { eq } from "drizzle-orm";

const router = express.Router();

// GET all partners
router.get("/", async (req, res) => {
  const userId = req.user?.id; // pulled from Passport or session
  const partners = await db.select().from(villagePartners).where(eq(villagePartners.userId, userId));
  res.json(partners);
});

// POST create partner
router.post("/", async (req, res) => {
  const userId = req.user?.id;
  const { name, circleLevel, category, contactFrequency } = req.body;

  const [created] = await db.insert(villagePartners).values({
    userId,
    name,
    circleLevel,
    category,
    contactFrequency,
  }).returning();

  res.json(created);
});

// PUT edit partner
router.put("/:id", async (req, res) => {
  const userId = req.user?.id;
  const { id } = req.params;
  const { name, circleLevel, category, contactFrequency } = req.body;

  const [updated] = await db.update(villagePartners)
    .set({ name, circleLevel, category, contactFrequency })
    .where(eq(villagePartners.id, Number(id)))
    .returning();
  res.json(updated);
});

// DELETE partner
router.delete("/:id", async (req, res) => {
  const userId = req.user?.id;
  const { id } = req.params;

  const [deleted] = await db.delete(villagePartners)
    .where(eq(villagePartners.id, Number(id)))
    .returning();
  res.json(deleted);
});

export default router;
Register router in your Express app with something like app.use("/api/village-partners", router);

3. Front-End Architecture
a. Fetching & Caching with React Query
Use react-query (TanStack Query) to fetch the user’s village partners from your new endpoints:

ts
Copy
// hooks/useVillagePartners.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";

export function useVillagePartners() {
  return useQuery(["villagePartners"], async () => {
    const { data } = await axios.get("/api/village-partners");
    return data;
  });
}

export function useCreateVillagePartner() {
  const queryClient = useQueryClient();
  return useMutation(
    async (payload) => {
      const { data } = await axios.post("/api/village-partners", payload);
      return data;
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["villagePartners"]);
      },
    }
  );
}

export function useUpdateVillagePartner() {
  const queryClient = useQueryClient();
  return useMutation(
    async ({ id, ...payload }) => {
      const { data } = await axios.put(`/api/village-partners/${id}`, payload);
      return data;
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["villagePartners"]);
      },
    }
  );
}

export function useDeleteVillagePartner() {
  const queryClient = useQueryClient();
  return useMutation(
    async (id) => {
      const { data } = await axios.delete(`/api/village-partners/${id}`);
      return data;
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["villagePartners"]);
      },
    }
  );
}
b. Displaying Five Concentric Circles
There are a few ways to render concentric circles in React. One approach is a CSS-based technique (using absolute positioning, border-radius, etc.). Another approach is using an SVG or <canvas> for the radial layout.

Option 1: CSS Circles
You could create a container for each circle, absolutely positioned, with increasing diameter. Then place items (Village Partners) at some angles around the circle or keep them horizontally aligned.

Option 2: SVG / <canvas>
For more advanced radial layouts or easy pinch/zoom, an <svg> with transforms might be more flexible.

For simplicity, let’s say you have a container that is relatively positioned, and each circle is absolutely positioned within it.

tsx
Copy
// components/Village.tsx
import React from "react";
import { useVillagePartners } from "../hooks/useVillagePartners";
import VillageCircle from "./VillageCircle";

const NUM_CIRCLES = 5;

export default function Village() {
  const { data: partners, isLoading } = useVillagePartners();

  if (isLoading) return <div>Loading...</div>;

  // Group partners by circle
  const circleMap: Record<number, any[]> = { 1: [], 2: [], 3: [], 4: [], 5: [] };
  partners?.forEach((partner) => {
    circleMap[partner.circleLevel].push(partner);
  });

  return (
    <div className="relative w-full h-[600px] overflow-hidden touch-pan-y">
      {/* Core Family in the center */}
      <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center justify-center">
        <div className="bg-green-100 rounded-full p-4 text-center">
          Kerngezin
        </div>
      </div>

      {/* 5 circles */}
      {[...Array(NUM_CIRCLES)].map((_, i) => (
        <VillageCircle 
          key={i}
          circleNumber={i + 1}
          partners={circleMap[i + 1]}
        />
      ))}
    </div>
  );
}
This component relies on a child VillageCircle to actually place the partner nodes.

c. Placing Partners on Each Circle
VillageCircle might position each partner’s node around the circle in a uniform or random radial manner. Alternatively, you could just cluster them near the circle if you’re aiming for a simpler design.

tsx
Copy
// components/VillageCircle.tsx
import React from "react";

type Partner = {
  id: number;
  name: string;
  // ...
};

interface Props {
  circleNumber: number;
  partners: Partner[];
}

export default function VillageCircle({ circleNumber, partners }: Props) {
  // Some function that calculates circle radius based on circleNumber
  const radius = circleNumber * 80; 

  return (
    <div
      className="absolute rounded-full border-2 border-gray-300"
      style={{
        width: radius * 2,
        height: radius * 2,
        top: `calc(50% - ${radius}px)`,
        left: `calc(50% - ${radius}px)`,
      }}
    >
      {partners.map((partner, index) => {
        // Example: evenly distribute items around the circle
        const angle = (index / partners.length) * 2 * Math.PI;
        const x = radius + radius * 0.8 * Math.cos(angle);
        const y = radius + radius * 0.8 * Math.sin(angle);

        return (
          <div
            key={partner.id}
            className="absolute bg-white border rounded-full p-2"
            style={{
              top: y,
              left: x,
              transform: "translate(-50%, -50%)",
            }}
          >
            {partner.name}
          </div>
        );
      })}
    </div>
  );
}
You can refine the math/positions to match your aesthetic.
Add styling from Tailwind or Shadcn/UI to achieve the final look.
d. Pinch & Zoom
For pinch/zoom on mobile, consider one of these approaches:

Use a library such as use-gesture in combination with Framer Motion or React’s built-in transformations.
Manual: handle touchstart, touchmove, etc., track the distance between fingers, and apply a scale transform on your container.
Framer Motion also allows you to set up pan and pinch gestures via <motion.div>:

tsx
Copy
<motion.div
  style={{ originX: 0.5, originY: 0.5 }}
  drag
  dragConstraints={{ left: -100, right: 100, top: -100, bottom: 100 }}
  whileTap={{ cursor: "grabbing" }}
  animate={{ scale }}
  onPinchStart={...}
  onPinch={...}
  onPinchEnd={...}
>
  {/* Content with your circles */}
</motion.div>
e. Editing Existing Partners
To edit a partner, you can do:

On click of a partner node, open a modal or side panel.
Use the partner’s data to fill in a form (similar to your screenshot).
On submit, call your useUpdateVillagePartner mutation.
For example:

tsx
Copy
// VillagePartnerModal.tsx
function VillagePartnerModal({ partner, onClose }) {
  const updatePartner = useUpdateVillagePartner();

  const [formData, setFormData] = useState({
    name: partner.name,
    circleLevel: partner.circleLevel,
    category: partner.category,
    contactFrequency: partner.contactFrequency
  });

  const handleSubmit = () => {
    updatePartner.mutate({ id: partner.id, ...formData });
    onClose();
  };

  return (
    <Modal onClose={onClose}>
      {/* Inputs for name, circleLevel, etc. */}
      <button onClick={handleSubmit}>Save</button>
    </Modal>
  );
}
f. AI Context From Each Village Member
You mentioned that each partner’s context should be accessible by your AI chat. Typically that means you’d have a function that, when the user opens the AI chat, you can fetch relevant context from the database.

For example, you might do something like:

ts
Copy
// AI chat handler
async function getAIContextForUser(userId) {
  const partners = await db.select().from(villagePartners).where(eq(villagePartners.userId, userId));
  // Format the partner data into a prompt or store it in Mem0 AI for retrieval
  return partners.map(p => ({
    name: p.name,
    circle: p.circleLevel,
    category: p.category,
    contactFrequency: p.contactFrequency,
  }));
}
Then pass that context to your Chat GPT / Claude / Mem0 calls so that the AI can reference it.

4. Putting It All Together
Backend

Create the village_partners table (via Drizzle migrations).
Set up CRUD endpoints in Express.
Frontend

Use React Query hooks to fetch, create, update, and delete partners.
Build the “Village” UI with a central “core family” node and five concentric circles.
Render each partner in the correct circle.
Implement pinch/zoom (via Framer Motion or a custom pinch handler).
Editing

Attach a click handler to each partner’s node.
Open a modal or side panel to edit that partner’s details.
Persistence

Because it’s all stored in village_partners, data will persist across sessions/logins.
AI Integration

When calling your AI chat endpoint, pull the user’s village data from village_partners and feed it to the prompt or memory context.
This approach cleanly fits into your existing stack (React 18 + Vite + Tailwind + Node/Express + Drizzle + PostgreSQL) and leverages your existing patterns (React Query for data, authentication via Passport, session management, etc.).

Key Takeaways
Store village partners in a dedicated table with user ID references.
Render concentric circles either via CSS or an SVG-based approach.
Manage data with React Query’s standard patterns (fetch, mutate).
Enable pinch/zoom with Framer Motion or a gesture library.
Expose the data to your AI logic by fetching from the database and including it in your prompt or memory mechanism.